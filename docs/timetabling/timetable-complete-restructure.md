# Timetable Processing System Updates - Complete Restructure

## Summary of Changes

This update completely restructures how timetable files are stored and processed, implementing a more organized approach with comprehensive file storage.

## ğŸ—ï¸ New Directory Structure

### Before
```
schools/{schoolId}/
â”œâ”€â”€ {randomFileName}.fet (input)
â””â”€â”€ outputs/
    â”œâ”€â”€ timetable_{id}_output_{timestamp}.fet
    â””â”€â”€ {id}_{filename}.html
```

### After
```
schools/{schoolId}/
â””â”€â”€ {timetableId}/
    â”œâ”€â”€ input/
    â”‚   â””â”€â”€ {originalFileName}.fet
    â””â”€â”€ output/
        â”œâ”€â”€ {all_generated_files}
        â”œâ”€â”€ timetable.fet
        â”œâ”€â”€ *.html
        â”œâ”€â”€ *.csv
        â”œâ”€â”€ *.txt
        â””â”€â”€ ... (any other FET outputs)
```

## ğŸ”„ Key Changes Made

### 1. Complete File Storage (`processTimetable.ts`)
- **Removed File Filtering**: ALL files generated by `fet-cl` are now uploaded to object storage
- **New Structure**: Files organized by `{schoolId}/{timetableId}/input|output/`
- **Content-Type Detection**: Automatic MIME type detection for different file extensions
- **Comprehensive Upload**: No files are left behind - everything gets stored

### 2. Separated Processing Concerns
- **Storage Phase**: Focus purely on uploading all raw generated files
- **Processing Phase**: Moved to separate utility functions (can be called later)
- **Clean Separation**: Raw file storage vs. data processing are now distinct steps

### 3. Enhanced Object Storage Structure
- **Input Storage**: Input files are copied to the structured location during processing
- **Output Storage**: All FET-generated files are stored with original names
- **Organization**: Clear hierarchy makes files easy to locate and manage

## ğŸ“ File Types Now Stored

The system now captures ALL files generated by FET, including:
- `.fet` - Main timetable XML output
- `.html` - Human-readable timetable views
- `.csv` - CSV export data (if enabled)
- `.txt` - Statistics and reports
- Any other files FET generates

## ğŸ› ï¸ New Utility Functions

Created `timetableFileManager.ts` with helper functions:

### `processTimetableOutputFiles(schoolId, timetableId)`
Processes the stored FET output files and saves to database (to be called separately)

### `getTimetableFiles(schoolId, timetableId)`
Lists all available input and output files for a timetable

### `getTimetableFile(schoolId, timetableId, type, fileName)`
Retrieves a specific file from storage

### `getTimetableHTMLFiles(schoolId, timetableId)`
Gets all HTML files for display purposes

## ğŸ”§ Implementation Details

### Enhanced FET Command
The system uses comprehensive FET parameters:
```bash
fet-cl --inputfile="input.fet" --outputdir="output/" --htmllevel=7 --exportcsv=true
```

### Content-Type Detection
```typescript
let contentType = 'application/octet-stream';
if (fileExtension === 'html' || fileExtension === 'htm') {
    contentType = 'text/html';
} else if (fileExtension === 'xml' || fileExtension === 'fet') {
    contentType = 'application/xml';
} else if (fileExtension === 'csv') {
    contentType = 'text/csv';
} else if (fileExtension === 'txt') {
    contentType = 'text/plain';
}
```

### Upload Process
```typescript
// Upload to new structure: {schoolId}/{timetableId}/output/{fileName}
const outputObjectKey = `${schoolId}/${timetableId}/output/${fileName}`;
await uploadBufferHelper(
    Buffer.from(fileContent.stdout, 'utf-8'),
    'schools',
    outputObjectKey,
    contentType
);
```

## ğŸš€ Processing Workflow

### Phase 1: Generation & Storage (Current)
1. Generate FET input file
2. Store in temporary location (existing flow)
3. Process with FET in Docker container  
4. Move input file to `{schoolId}/{timetableId}/input/`
5. Upload ALL output files to `{schoolId}/{timetableId}/output/`

### Phase 2: Data Processing (Future)
1. Call `processTimetableOutputFiles()` to process the stored files
2. Extract timetable data from the .fet file
3. Store processed data in database
4. Mark timetable as ready for use

## âœ… Benefits

### Organization
- **Clear Structure**: Easy to find files for any timetable
- **Complete Records**: Nothing is lost in processing
- **Scalable**: Structure works for unlimited schools/timetables

### Flexibility
- **Deferred Processing**: Can process files later if needed
- **Multiple Uses**: Raw files can be used for different purposes
- **Recovery**: Complete data preservation enables recovery from processing errors

### Maintainability
- **Separation of Concerns**: Storage vs. processing are distinct
- **Testability**: Each phase can be tested independently
- **Debugging**: Can inspect raw files when troubleshooting

## ğŸ“‹ Files Modified

### Modified Files
- `src/scripts/processTimetable.ts` - Complete restructure for new storage approach
- `docs/timetable-storage-structure.md` - Documentation of new structure

### New Files
- `src/lib/server/timetableFileManager.ts` - Utility functions for file management
- `docs/timetable-processing-updates.md` - Complete change documentation

## ğŸ”® Future Enhancements

### API Endpoints
Create endpoints to access stored files:
```typescript
GET /api/timetables/{id}/files           // List all files
GET /api/timetables/{id}/files/output    // List output files
GET /api/timetables/{id}/files/{filename} // Download specific file
```

### Processing Pipeline
Implement a more sophisticated processing pipeline:
1. **Storage** (current implementation)
2. **Processing** (using new utility functions)  
3. **Validation** (verify processed data)
4. **Publishing** (make available to users)

### File Management
- **Retention Policies**: Automatic cleanup of old files
- **Compression**: Compress stored files to save space
- **Versioning**: Keep multiple versions of timetable generations

## ğŸ¯ Next Steps

1. **Test the new storage structure** with a complete timetable generation
2. **Implement processing phase** using the new utility functions
3. **Create API endpoints** for file access
4. **Add file management features** (cleanup, versioning, etc.)

The system is now much more robust and organized, providing complete preservation of all generated files while maintaining clear separation between storage and processing concerns.